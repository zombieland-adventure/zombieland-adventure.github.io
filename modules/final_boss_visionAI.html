<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEMESIS: FASE FINAL</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core@3.11.0/dist/tf-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter@3.11.0/dist/tf-converter.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@3.11.0/dist/tf-backend-webgl.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@0.0.6/dist/pose-detection.min.js"></script>

    <style>
        body { background: #000; color: #0f0; overflow: hidden; font-family: 'Courier New', monospace; user-select: none; margin: 0; padding: 0; }
        
        #game-layer { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            z-index: 1; 
        }
        
        /* Video silenciado y oculto */
        video { position: absolute; top: 0; left: 0; width: 1px; height: 1px; opacity: 0; pointer-events: none; }
        canvas { display: block; width: 100%; height: 100%; transform: scaleX(-1); }

        #ui-layer { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            pointer-events: none; z-index: 20; 
            display: flex; flex-direction: column; justify-content: space-between; padding: 20px; box-sizing: border-box;
        }
        
        #prompt-container {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; width: 100%; text-shadow: 0 0 10px #000;
        }
        .action-big { font-size: 12vw; font-weight: 900; display: block; line-height: 1; transition: transform 0.1s; }
        .action-sub { font-size: 5vw; font-weight: bold; display: block; margin-top: 10px; color: #fff; }
        
        #action-timer-bar {
            width: 50%; height: 10px; background: #555; margin: 20px auto 0;
            border-radius: 5px; overflow: hidden; display: none;
        }
        #action-timer-fill {
            width: 100%; height: 100%; background: #fff; transform-origin: left;
        }

        #start-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.95); z-index: 50; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; padding: 20px; }
        button { padding: 20px 50px; font-size: 1.5rem; background: #00cc00; color: white; border: 2px solid white; font-weight: bold; cursor: pointer; border-radius: 10px; margin-top: 20px; }
        button:active { transform: scale(0.95); }

        #win-screen, #lose-screen { position: fixed; inset: 0; background: #000; z-index: 60; display: none; flex-direction: column; align-items: center; justify-content: center; text-align: center; }
        .ko-text { font-size: 25vw; color: #ff0000; font-weight: 900; animation: pulse-ko 1s infinite; text-shadow: 0 0 30px red; line-height: 0.8; }
        @keyframes pulse-ko { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }
        
        #lose-screen button { color: white !important; border-color: white !important; }

        #debug-log { position: absolute; bottom: 10px; left: 10px; font-size: 12px; color: yellow; background: rgba(0,0,0,0.5); padding: 5px; text-align: left; }

        .damage-effect { animation: shake 0.3s; box-shadow: inset 0 0 100px red; }
        .heal-effect { animation: pulse 0.5s; box-shadow: inset 0 0 50px #00ff00; }
        @keyframes shake { 0%, 100% { transform: translate(0,0); } 25% { transform: translate(10px,0); } 75% { transform: translate(-10px,0); } }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.8; } }

        /* QTE */
        #qte-overlay {
            position: fixed; inset: 0; background: rgba(0,0,0,0.9); z-index: 100;
            display: none; align-items: center; justify-content: center; cursor: pointer;
        }
        .qte-circle {
            width: 200px; height: 200px; position: relative;
            display: flex; align-items: center; justify-content: center;
        }
        .qte-cross {
            font-size: 100px; color: #fff; font-weight: 900; text-shadow: 0 0 20px #0f0;
            z-index: 2; pointer-events: none;
        }
        .qte-progress {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            border-radius: 50%; border: 10px solid #333;
            box-sizing: border-box;
        }
        .qte-fill {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            border-radius: 50%; border: 10px solid #0f0; border-top-color: transparent;
            box-sizing: border-box; 
            animation: spin-drain 4s linear forwards;
        }
        @keyframes spin-drain { 0% { transform: rotate(0deg); opacity: 1; } 100% { transform: rotate(360deg); opacity: 0; } }
        
        .mic-indicator {
            position: absolute; top: 10px; right: 10px; width: 20px; height: 20px; border-radius: 50%;
            background: #333; border: 2px solid #555; transition: all 0.1s;
        }
        .mic-active { background: #0f0; box-shadow: 0 0 10px #0f0; }

    </style>
</head>
<body>

    <!-- PANTALLA INICIO -->
    <div id="start-overlay">
        <h1 class="text-4xl md:text-6xl text-green-500 mb-4 font-bold tracking-widest">NEMESIS</h1>
        <p class="text-gray-300 text-lg mb-2 max-w-md">Coloca el móvil apoyado y aléjate hasta que se te vea de cintura para arriba.</p>
        <p class="text-yellow-500 text-sm mb-8 animate-pulse">[MICRÓFONO REQUERIDO PARA GRITOS DE PODER]</p>
        <button onclick="initSystem()">INICIAR COMBATE</button>
    </div>

    <!-- PANTALLA VICTORIA -->
    <div id="win-screen">
        <div class="ko-text">K.O.</div>
        <h2 class="text-white text-2xl md:text-4xl mt-4 tracking-widest font-bold">OBJETIVO ELIMINADO</h2>
        <p class="text-yellow-500 mt-8 text-xl animate-pulse tracking-widest">>> OBJETO DESCONOCIDO SOLTADO <<</p>
        <button onclick="location.href='tomb_treasure.html'" style="margin-top: 40px; background: transparent; border: 1px solid #0f0; color: #0f0;">RECOGER RECOMPENSA</button>
    </div>

    <!-- PANTALLA DERROTA -->
    <div id="lose-screen">
        <h2 class="text-red-600 text-4xl md:text-6xl mb-4 font-bold tracking-widest">SISTEMA CRÍTICO</h2>
        <p class="text-gray-400 mt-4">Has recibido demasiado daño.</p>
        <button onclick="location.reload()" style="background: red; border-color: red;">REINTENTAR</button>
    </div>

    <!-- QTE OVERLAY -->
    <div id="qte-overlay" onclick="handleQTEClick()">
        <div class="qte-circle">
            <div class="qte-progress"></div>
            <div id="qte-anim" class="qte-fill"></div>
            <div class="qte-cross">+</div>
        </div>
        <p class="absolute bottom-20 text-white font-bold text-2xl animate-bounce">¡PULSA!</p>
    </div>

    <!-- JUEGO -->
    <div id="game-layer">
        <!-- MUTED para evitar feedback de audio -->
        <video id="video" playsinline muted></video>
        <canvas id="output"></canvas>
    </div>

    <!-- HUD -->
    <div id="ui-layer" style="display:none;">
        <div class="mic-indicator" id="mic-led"></div>
        
        <div class="w-full flex justify-between items-start gap-4">
            <!-- Jugador -->
            <div class="w-1/3 max-w-sm">
                <div class="flex justify-between text-white font-bold text-sm md:text-lg drop-shadow-md">
                    <span class="text-blue-400">JUGADOR</span>
                </div>
                <div class="w-full h-4 md:h-6 border-2 border-blue-900 bg-black mt-1 relative rounded">
                    <div id="player-hp-bar" class="h-full bg-gradient-to-r from-blue-600 to-cyan-400 transition-all duration-300" style="width: 100%"></div>
                </div>
            </div>
            <!-- Boss -->
            <div class="w-1/2 max-w-2xl text-right">
                <div class="flex justify-end text-white font-bold text-xl drop-shadow-md">
                    <span class="text-red-500 text-2xl mr-2">NEMESIS</span>
                    <span id="score-txt">100%</span>
                </div>
                <div class="w-full h-6 md:h-10 border-4 border-red-900 bg-black mt-2 relative rounded shadow-lg shadow-red-900/50">
                    <div id="hp-bar" class="h-full bg-gradient-to-r from-red-600 to-red-400 transition-all duration-300" style="width: 100%"></div>
                </div>
            </div>
        </div>

        <!-- Instrucciones Centrales -->
        <div id="prompt-container">
            <span id="main-action" class="action-big text-yellow-400">CALIBRANDO</span>
            <span id="sub-action" class="action-sub">...</span>
            <div id="action-timer-bar"><div id="action-timer-fill"></div></div>
        </div>

        <div id="debug-log">Iniciando...</div>
    </div>

    <script>
        // --- CONFIGURACIÓN ---
        const TOTAL_MOVES = 30;       
        const DODGE_BASE_CHANCE = 0.25;
        const PLAYER_MAX_HP = 5; 
        const TIME_LIMIT_PUNCH = 5000; 
        const TIME_LIMIT_DODGE = 2500; 
        
        // --- ESTADO ---
        let detector, video, canvas, ctx;
        let state = 'INIT'; 
        let score = 0;
        let playerHP = PLAYER_MAX_HP;
        let currentOrder = null; 
        let isMirror = false; 
        let isHitProcessing = false;
        let lastProcessTime = 0; // Para el Watchdog anti-freeze
        
        let renderScale = 1;
        let renderOffsetX = 0;
        let renderOffsetY = 0;
        
        let lastPositions = { lx:0, ly:0, rx:0, ry:0, ny:0 }; 
        let refPoints = { noseY: 0, shoulderY: 0, shoulderWidth: 0 };
        
        let hookCharge = { left: false, right: false };
        let punchCooldown = 0; 
        let moveHistory = []; 
        let actionStartTime = 0;
        
        // Mecánicas
        let streakCount = 0; 
        let shoutCooldown = 0;
        let analyser, dataArray; 
        let qteTimer = null;

        // --- AUDIO ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playTone(type) {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            const t = audioCtx.currentTime;
            
            if(type === 'hit') { 
                osc.type = 'square'; osc.frequency.setValueAtTime(100, t); osc.frequency.linearRampToValueAtTime(50, t+0.1);
                g.gain.setValueAtTime(0.5, t); g.gain.linearRampToValueAtTime(0, t+0.1);
                osc.start(t); osc.stop(t+0.1);
            } else if (type === 'voice') { 
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(300, t);
                g.gain.setValueAtTime(0.2, t); g.gain.linearRampToValueAtTime(0, t+0.3);
                osc.start(t); osc.stop(t+0.3);
            } else if (type === 'error') {
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, t); osc.frequency.linearRampToValueAtTime(50, t+0.4);
                g.gain.setValueAtTime(0.5, t); osc.start(t); osc.stop(t+0.4);
            } else if (type === 'heal') {
                osc.type = 'sine'; osc.frequency.setValueAtTime(400, t); osc.frequency.linearRampToValueAtTime(800, t+0.5);
                g.gain.setValueAtTime(0.3, t); osc.start(t); osc.stop(t+0.5);
            } else if (type === 'calibrated') {
                osc.type = 'sine'; osc.frequency.setValueAtTime(440, t); osc.frequency.linearRampToValueAtTime(880, t+0.3);
                g.gain.setValueAtTime(0.2, t); osc.start(t); osc.stop(t+0.3);
            }
            osc.connect(g); g.connect(audioCtx.destination);
        }

        // --- INICIO ---
        async function initSystem() {
            document.getElementById('start-overlay').style.display = 'none';
            document.getElementById('ui-layer').style.display = 'flex';
            log("Cargando sensores...");

            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: 'user', width: {ideal: 640}, height: {ideal: 480} },
                    audio: true 
                });
                
                video = document.getElementById('video');
                // IMPORTANTE: Asegurar mute para evitar feedback loop
                video.muted = true;
                
                canvas = document.getElementById('output');
                ctx = canvas.getContext('2d');
                video.srcObject = stream;
                
                const audioStream = audioCtx.createMediaStreamSource(stream);
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 256;
                audioStream.connect(analyser);
                dataArray = new Uint8Array(analyser.frequencyBinCount);

                await new Promise(r => video.onloadedmetadata = () => {
                    video.play();
                    handleResize();
                    r();
                });

                log("Cargando IA...");
                const model = poseDetection.SupportedModels.MoveNet;
                detector = await poseDetection.createDetector(model, { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING });
                
                window.addEventListener('resize', handleResize);
                log("Calibrando...");
                startCalibration();
                loop();

            } catch (e) {
                alert("Error de acceso: " + e.message + "\nActiva permisos de cámara y micrófono.");
                location.reload();
            }
        }

        function handleResize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            const vidRatio = video.videoWidth / video.videoHeight;
            const screenRatio = canvas.width / canvas.height;
            
            if (screenRatio > vidRatio) {
                renderScale = canvas.width / video.videoWidth;
                renderOffsetX = 0;
                renderOffsetY = (canvas.height - (video.videoHeight * renderScale)) / 2;
            } else {
                renderScale = canvas.height / video.videoHeight;
                renderOffsetX = (canvas.width - (video.videoWidth * renderScale)) / 2;
                renderOffsetY = 0;
            }
        }

        function log(msg) { document.getElementById('debug-log').innerText = msg; }

        // --- SISTEMA DE GRITOS (CURA) ---
        function checkAudioLevel() {
            if (!analyser || state !== 'PLAYING') return;
            if (shoutCooldown > 0) { shoutCooldown--; return; }

            analyser.getByteFrequencyData(dataArray);
            let sum = 0;
            for(let i = 0; i < dataArray.length; i++) sum += dataArray[i];
            let average = sum / dataArray.length;

            if (average > 60) { 
                document.getElementById('mic-led').classList.add('mic-active');
                healPlayer(1, "¡GRITO DE PODER!");
                shoutCooldown = 200; 
                setTimeout(() => document.getElementById('mic-led').classList.remove('mic-active'), 500);
            }
        }

        // --- QTE SYSTEM ---
        function triggerQTE() {
            if (state !== 'PLAYING') return;
            state = 'QTE'; 
            
            const qte = document.getElementById('qte-overlay');
            qte.style.display = 'flex';
            
            const fill = document.getElementById('qte-anim');
            fill.style.animation = 'none';
            fill.offsetHeight; 
            fill.style.animation = 'spin-drain 4s linear forwards';

            qteTimer = setTimeout(() => {
                handleQTEFail();
            }, 4000);
        }

        function handleQTEClick() {
            if (state !== 'QTE') return;
            clearTimeout(qteTimer);
            playTone('heal');
            healPlayer(PLAYER_MAX_HP, "¡RECUPERACIÓN TOTAL!"); 
            document.getElementById('qte-overlay').style.display = 'none';
            state = 'PLAYING';
            setTimeout(nextMove, 1000);
        }

        function handleQTEFail() {
            document.getElementById('qte-overlay').style.display = 'none';
            playTone('error');
            state = 'PLAYING';
            handleMiss("¡OPORTUNIDAD PERDIDA!");
        }

        // --- BUCLE PRINCIPAL ---
        async function loop() {
            if(state === 'WIN' && !video.paused) return; 

            // Watchdog: Anti-congelamiento
            // Si el juego está en "Procesando Golpe" por más de 2 segundos, reseteamos a la fuerza
            if (state === 'PLAYING' && isHitProcessing) {
                if (Date.now() - lastProcessTime > 2000) {
                    console.warn("Watchdog: Resetting stuck state");
                    isHitProcessing = false;
                    resetRound();
                }
            }

            checkAudioLevel();

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(video, 
                0, 0, video.videoWidth, video.videoHeight,
                renderOffsetX, renderOffsetY, video.videoWidth * renderScale, video.videoHeight * renderScale
            );

            if (state !== 'LOSE' && state !== 'WIN') {
                const poses = await detector.estimatePoses(video);
                if (poses.length > 0) {
                    const kp = poses[0].keypoints;
                    drawSkeleton(kp); 
                    if (state === 'CALIBRATING') processCalibration(kp);
                    else if (state === 'GUARD_CHECK') processGuardCheck(kp);
                    else if (state === 'PLAYING') processGameplay(kp);
                }
            }

            // Actualizar Barra Tiempo
            if (state === 'PLAYING' && currentOrder && !isHitProcessing) {
                const elapsed = Date.now() - actionStartTime;
                const limit = currentOrder.type === 'ESQUIVA' ? TIME_LIMIT_DODGE : TIME_LIMIT_PUNCH;
                const pct = Math.max(0, 100 - ((elapsed / limit) * 100));
                document.getElementById('action-timer-fill').style.width = `${pct}%`;
                if (elapsed > limit) handleMiss("¡LENTO!");
            }

            requestAnimationFrame(loop);
        }

        // --- FASE 1: CALIBRACIÓN ---
        function startCalibration() {
            state = 'CALIBRATING';
            updatePrompt("LEVANTA", "MANO DERECHA", "yellow");
        }

        let calibrationFrames = 0;
        function processCalibration(kp) {
            const lW = kp.find(k => k.name === 'left_wrist');
            const rW = kp.find(k => k.name === 'right_wrist');
            const nose = kp.find(k => k.name === 'nose');
            const lS = kp.find(k => k.name === 'left_shoulder');
            const rS = kp.find(k => k.name === 'right_shoulder');

            if(!lW || !rW || !nose || !lS || !rS) return;

            refPoints.noseY = nose.y;
            refPoints.shoulderY = (lS.y + rS.y) / 2; 
            refPoints.shoulderWidth = Math.abs(lS.x - rS.x);

            const leftIsUp = lW.y < nose.y - 50;
            const rightIsUp = rW.y < nose.y - 50;

            if (leftIsUp || rightIsUp) {
                calibrationFrames++;
                if(calibrationFrames > 40) {
                    if (leftIsUp) isMirror = true; 
                    else isMirror = false; 

                    playTone('calibrated');
                    log(`Espejo: ${isMirror}. Calibrado.`);
                    startGuardCheck();
                }
            } else {
                calibrationFrames = 0;
            }
        }

        // --- FASE 1.5: GUARDIA ---
        let guardFrames = 0;
        function startGuardCheck() {
            state = 'GUARD_CHECK';
            updatePrompt("¡EN GUARDIA!", "PUÑOS ARRIBA", "white");
        }

        function processGuardCheck(kp) {
            const lW = kp.find(k => k.name === 'left_wrist');
            const rW = kp.find(k => k.name === 'right_wrist');
            const nose = kp.find(k => k.name === 'nose');
            
            if(!lW || !rW || !nose) return;
            const handsUp = lW.y < nose.y + 100 && rW.y < nose.y + 100;

            if(handsUp) {
                guardFrames++;
                if(guardFrames > 50) { 
                    playTone('calibrated');
                    state = 'PLAYING';
                    // Inicializar historial
                    lastPositions = { lx: lW.x, rx: rW.x, ly: lW.y, ry: rW.y, ny: nose.y };
                    setTimeout(nextMove, 1000);
                }
            } else {
                guardFrames = 0;
            }
        }

        // --- FASE 2: JUEGO ---
        function nextMove() {
            if(state !== 'PLAYING') return;
            isHitProcessing = false;

            if (playerHP <= 2 && Math.random() < 0.4) {
                triggerQTE();
                return;
            }

            let dodgeProbability = DODGE_BASE_CHANCE;
            if (moveHistory[0] === 'ESQUIVA') dodgeProbability -= 0.30;
            if (dodgeProbability < 0) dodgeProbability = 0;

            const type = Math.random() < dodgeProbability ? 'ESQUIVA' : 'GOLPE';
            const side = Math.random() > 0.5 ? 'IZQUIERDA' : 'DERECHA';

            let actionName = "JAB";
            if (type === 'GOLPE' && Math.random() > 0.5) actionName = "GANCHO";
            if (type === 'ESQUIVA') actionName = "ESQUIVA";

            moveHistory.unshift(actionName); 
            if (moveHistory.length > 3) moveHistory.pop();

            currentOrder = { type: actionName, side: side };
            actionStartTime = Date.now(); 

            let color = "#fff";
            if (side === 'IZQUIERDA') color = "#00ffff"; 
            else color = "#ff00ff"; 

            let mainTxt = actionName;
            let subTxt = side;
            if(actionName === "ESQUIVA") { mainTxt = "¡ABAJO!"; subTxt = "ESQUIVA " + side; }

            updatePrompt(mainTxt, subTxt, color);
            document.getElementById('action-timer-bar').style.display = 'block';
            playTone('voice');
        }

        function processGameplay(kp) {
            if (punchCooldown > 0) punchCooldown--;

            const rawLeft = kp.find(k => k.name === 'left_wrist');
            const rawRight = kp.find(k => k.name === 'right_wrist');
            const nose = kp.find(k => k.name === 'nose');
            const lS = kp.find(k => k.name === 'left_shoulder');
            const rS = kp.find(k => k.name === 'right_shoulder');

            if(!rawLeft || !rawRight || !nose || !lS || !rS) return;

            let userLeftWrist, userRightWrist;
            if (isMirror) { userLeftWrist = rawRight; userRightWrist = rawLeft; } 
            else { userLeftWrist = rawLeft; userRightWrist = rawRight; }

            // Calcular velocidades
            const prevLx = lastPositions.lx || userLeftWrist.x;
            const prevRx = lastPositions.rx || userRightWrist.x;
            const prevLy = lastPositions.ly || userLeftWrist.y; // Añadido Y para ganchos
            const prevRy = lastPositions.ry || userRightWrist.y;

            const vxL = Math.abs(userLeftWrist.x - prevLx);
            const vxR = Math.abs(userRightWrist.x - prevRx);
            
            // Velocidad Vertical (para ganchos: debe ser negativa/subiendo)
            const vyL = userLeftWrist.y - prevLy; 
            const vyR = userRightWrist.y - prevRy;

            // Actualizar historial
            lastPositions = { lx: userLeftWrist.x, rx: userRightWrist.x, ly: userLeftWrist.y, ry: userRightWrist.y, ny: nose.y };

            if(!currentOrder || isHitProcessing) return;

            refPoints.shoulderY = (refPoints.shoulderY * 0.9) + (((lS.y + rS.y)/2) * 0.1); 
            const punchThreshold = 15; 
            const chargeLevelY = refPoints.shoulderY + 80;
            if (userLeftWrist.y > chargeLevelY) hookCharge.left = true;
            if (userRightWrist.y > chargeLevelY) hookCharge.right = true;

            // --- DETECCIÓN ---
            let detectedMove = null;
            let detectedSide = null;

            // JAB
            if (vxL > punchThreshold && userLeftWrist.y < (refPoints.shoulderY + 60)) { detectedMove = 'JAB'; detectedSide = 'IZQUIERDA'; }
            if (vxR > punchThreshold && userRightWrist.y < (refPoints.shoulderY + 60)) { detectedMove = 'JAB'; detectedSide = 'DERECHA'; }

            // GANCHO (Mejorado: Requiere velocidad SUBIENDO)
            // vy debe ser negativo (subir) y rápido (< -5)
            if (hookCharge.left && vxL > punchThreshold && vyL < -5 && userLeftWrist.y < chargeLevelY) { detectedMove = 'GANCHO'; detectedSide = 'IZQUIERDA'; }
            if (hookCharge.right && vxR > punchThreshold && vyR < -5 && userRightWrist.y < chargeLevelY) { detectedMove = 'GANCHO'; detectedSide = 'DERECHA'; }

            // ESQUIVA
            if (punchCooldown === 0 && nose.y > (refPoints.shoulderY + 50)) {
                const centerX = (lS.x + rS.x) / 2;
                const dx = nose.x - centerX;
                detectedMove = 'ESQUIVA';
                if ((isMirror && dx > 20) || (!isMirror && dx < -20)) detectedSide = 'IZQUIERDA';
                else if ((isMirror && dx < -20) || (!isMirror && dx > 20)) detectedSide = 'DERECHA';
                else detectedSide = 'CENTRO'; 
            }

            if (detectedMove) {
                // Resetear cargas si hubo golpe
                if (detectedMove === 'JAB' || detectedMove === 'GANCHO') {
                    punchCooldown = 20;
                    if(detectedSide === 'IZQUIERDA') hookCharge.left = false;
                    else hookCharge.right = false;
                }

                const isCorrectType = detectedMove === currentOrder.type;
                let isCorrectSide = detectedSide === currentOrder.side;
                if (detectedMove === 'ESQUIVA' && detectedSide === 'CENTRO') isCorrectSide = true;

                if (isCorrectType && isCorrectSide) {
                    isHitProcessing = true;
                    lastProcessTime = Date.now(); // Marca de tiempo para Watchdog
                    playTone('hit');
                    score++;
                    streakCount++;
                    
                    if(streakCount > 0 && streakCount % 5 === 0) healPlayer(1, "RACHA: +1 HP");

                    updateUI();
                    const mainAction = document.getElementById('main-action');
                    mainAction.style.transform = "scale(1.5)";
                    mainAction.style.color = "#0f0"; 
                    
                    if(score >= TOTAL_MOVES) setTimeout(doWin, 500);
                    else setTimeout(resetRound, 200);

                } else {
                    handleMiss();
                }
            }
        }

        function handleMiss(reason) {
            if (isHitProcessing) return; 
            isHitProcessing = true;
            lastProcessTime = Date.now(); // Marca de tiempo para Watchdog
            playTone('error');
            
            streakCount = 0; 
            playerHP--;
            updatePlayerHP();
            
            document.getElementById('ui-layer').classList.add('damage-effect');
            setTimeout(() => document.getElementById('ui-layer').classList.remove('damage-effect'), 300);

            const mainAction = document.getElementById('main-action');
            mainAction.innerText = reason || "¡FALLO!";
            mainAction.style.color = "red";

            if (playerHP <= 0) {
                setTimeout(doLose, 500);
            } else {
                setTimeout(resetRound, 600);
            }
        }

        function healPlayer(amount, msg) {
            if(playerHP < PLAYER_MAX_HP) {
                playerHP = Math.min(PLAYER_MAX_HP, playerHP + amount);
                updatePlayerHP();
                playTone('heal');
                
                document.getElementById('ui-layer').classList.add('heal-effect');
                setTimeout(() => document.getElementById('ui-layer').classList.remove('heal-effect'), 500);
                
                const sub = document.getElementById('sub-action');
                const prevText = sub.innerText;
                sub.innerText = msg;
                sub.style.color = "#0f0";
                setTimeout(() => { sub.innerText = prevText; sub.style.color = "white"; }, 1500);
            }
        }

        function resetRound() {
            isHitProcessing = false; // Asegurar desbloqueo
            const mainAction = document.getElementById('main-action');
            mainAction.style.transform = "scale(1)";
            currentOrder = null;
            document.getElementById('main-action').innerText = "";
            document.getElementById('sub-action').innerText = "";
            document.getElementById('action-timer-bar').style.display = 'none';
            setTimeout(nextMove, 600);
        }

        // --- UI ---
        function updatePrompt(main, sub, color) {
            const m = document.getElementById('main-action');
            const s = document.getElementById('sub-action');
            m.innerText = main;
            s.innerText = sub;
            m.style.color = color;
            m.style.transform = "scale(1)";
        }

        function updateUI() {
            const pct = Math.floor((score / TOTAL_MOVES) * 100);
            document.getElementById('score-txt').innerText = `${pct}% DAÑO`;
            document.getElementById('hp-bar').style.width = `${100 - pct}%`;
        }

        function updatePlayerHP() {
            const pct = (playerHP / PLAYER_MAX_HP) * 100;
            document.getElementById('player-hp-bar').style.width = `${pct}%`;
        }

        function doWin() {
            state = 'WIN';
            video.pause();
            if(video.srcObject) video.srcObject.getTracks().forEach(t => t.stop());
            document.getElementById('ui-layer').style.display = 'none';
            document.getElementById('game-layer').style.display = 'none'; 
            document.getElementById('win-screen').style.display = 'flex';
        }

        function doLose() {
            state = 'LOSE';
            video.pause();
            document.getElementById('ui-layer').style.display = 'none';
            document.getElementById('lose-screen').style.display = 'flex';
        }

        // --- DIBUJO ---
        function drawSkeleton(kp) {
            function map(pt) {
                return {
                    x: (pt.x * renderScale) + renderOffsetX,
                    y: (pt.y * renderScale) + renderOffsetY
                };
            }

            kp.forEach(p => {
                if(p.score > 0.4) {
                    const mapped = map(p);
                    ctx.beginPath();
                    ctx.arc(mapped.x, mapped.y, 5, 0, 2 * Math.PI); 
                    ctx.fillStyle = '#0f0';
                    ctx.fill();
                }
            });
            
            connect(kp, 'left_shoulder', 'left_elbow');
            connect(kp, 'left_elbow', 'left_wrist');
            connect(kp, 'right_shoulder', 'right_elbow');
            connect(kp, 'right_elbow', 'right_wrist');
            connect(kp, 'left_shoulder', 'right_shoulder');
        }

        function connect(kp, nameA, nameB) {
            const a = kp.find(k => k.name === nameA);
            const b = kp.find(k => k.name === nameB);
            if(a && b && a.score > 0.4 && b.score > 0.4) {
                const ma = { x: (a.x * renderScale) + renderOffsetX, y: (a.y * renderScale) + renderOffsetY };
                const mb = { x: (b.x * renderScale) + renderOffsetX, y: (b.y * renderScale) + renderOffsetY };

                ctx.beginPath();
                ctx.moveTo(ma.x, ma.y);
                ctx.lineTo(mb.x, mb.y);
                ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }
    </script>
</body>
</html>
